# 红点集团内部文档工具（前后一体 / 类 ComfyUI）开发文档

> 目标：做一个“对话驱动 + 工作流可视化 + 文档生产与整合”的集团内部文档工具。  
> 形态：前后一体设计（类似 ComfyUI 的节点/流程感），前端 TS+React，后端 Python（LangGraph/LangChain 工作流）。  
> 交互：左对话、中状态记录（可视化每个模型的下发内容/细化提示词）、右预览（Mermaid/HTML/最终文档）。

---

## 1. 产品范围（Scope）

- **核心能力**  
  - 与用户对话，逐步澄清“要写什么文档、受众、结构、约束、素材来源、风格等”，并沉淀为结构化 JSON 变量。  
  - 基于工作流（多模型/多节点）生成：文档草稿、润色、图文（Mermaid/HTML）、可选生图、全文整合。  
  - 全流程可视化：中间栏显示每个节点的“初步下发内容（细化提示词/约束/参考材料/产出格式）”及节点输出。  
  - 文档以 **Mermaid 为核心呈现**（同时允许插入 HTML 小组件），所有内容存服务器。  
  - 用户系统：最简用户名/密码注册登录，不分权限；“我的”查看自己文档；“抄送”查看别人分享给自己的文档；支持抄送（分享）文档给其他用户。

- **非目标（第一期不做/可后续）**  
  - 复杂 RBAC 权限、多组织、多租户。  
  - 多端（移动端）适配的极致体验。  
  - 大规模公网上线安全体系（内部环境可简化，但仍要做基础防护）。

---

## 2. 总体架构（前后一体 / 类 ComfyUI）

### 2.1 交互与渲染

- **左侧：对话**  
  - 以“中控对话模型”为主驱动，负责澄清需求、补全信息、校验完整性。  
  - 对话过程中持续更新“文档变量 JSON”（可视化展示/可编辑）。

- **中间：状态记录（工作流可视化）**  
  - 每个节点（模型/工具）都有：输入（细化提示词+变量+引用材料）、输出（草稿/图/HTML/图片地址等）、状态（pending/running/success/fail）、耗时、token/费用（可选）。  
  - **中间状态记录的核心就是“下发给各模型/节点的提示词与约束（node_prompt_spec）”**，以及节点输出。用户能直观看到“系统下发了什么、产出了什么”。  
  - 允许对节点输入进行微调后重跑节点或从某节点继续跑（第一期可先只做“重跑节点”）。

- **右侧：预览**  
  - 预览当前文档（Mermaid + Markdown + 可嵌入 HTML 片段）。  
  - 支持切换预览：阶段稿 / 最终稿 / 单节点产物（例如某张 Mermaid 图）。

### 2.2 后端：LangGraph 工作流（可视为“节点图执行器”）

后端把每个“模型职责”设计为可组合节点：
- 统一输入：`doc_variables`（JSON）+ `context_materials`（引用材料）+ `node_prompt_spec`（细化提示词）+ `history`（对话/执行历史）。
- 统一输出：`node_result`（结构化结果）+ `artifacts`（图/HTML/图片地址等）+ `patches`（对 doc_variables 的增量更新建议）。

> 注意：你希望“流程拆解不由 LLM 总控、流程模板固化”，因此工作流应以 **schema/模板** 固化节点顺序与可选分支，LLM 仅做选择/填充/校验（而非临时发明流程）。
>
> 选择 LangGraph 的原因：我们需要“状态机 + 节点重跑 + 失败回流闭环（回退给对应模型重制）”，LangGraph 更贴合这种可控编排。

---

## 3. 前端（TS + React）设计

### 3.1 页面结构

- **三栏布局**
  - **Left：ChatPanel**：对话列表、输入框、**文件/图片上传入口**（用于让用户说清楚概念）、引用材料上传/粘贴入口、快捷指令（开始撰写/重跑节点/生成目录等）。
  - **Middle：FlowPanel**：节点时间线/卡片流（类 ComfyUI 的节点执行感），展示每节点输入/输出与状态。
  - **Right：PreviewPanel**：Mermaid/Markdown/HTML 渲染预览、导出（doc/docx）按钮、版本切换。
  - 导出仅支持 **DOCX**（见第 8 章），不提供 DOC。

### 3.2 预览渲染（必须做好）

右侧展示区的渲染是“是否能说清楚一件事”的关键，必须作为一等公民来设计：

- **渲染目标**：预览区尽可能接近最终 `final_md` 的真实呈现（Mermaid 正确、HTML 原型可读、引用与图片稳定）。
- **Mermaid 渲染**：前端使用成熟渲染器（例如基于 Mermaid 官方渲染方案），并对渲染失败给出明确错误定位（图块 id/位置）。  
- **HTML 原型渲染**：在“受控容器”中渲染（限制样式影响范围、避免污染全局 CSS），确保可读与稳定。  
- **性能**：中间状态记录/日志可能很多，FlowPanel 需要虚拟列表/增量渲染，避免卡顿。

### 3.3 核心前端状态（建议）

- `sessionId`：一次文档制作会话
- `docId`：最终文档实体 ID（可与 session 1:1 或 1:n）
- `docVariables`：中控澄清得到的 JSON 变量（可展示为表单或 JSON 编辑器）
- `flowRuns[]`：一次或多次工作流执行记录（支持从某节点继续）
- `activePreviewVersion`：预览版本（阶段稿/最终稿/某节点产物）

---

## 4. 后端（Python）设计

### 4.1 技术栈建议

- Web 框架：FastAPI（或 Flask，但 FastAPI 更适合流式/异步/类型与文档）
- LangGraph：作为 workflow/state machine 的编排层（底层可用 LangChain 组件/模型封装）
- 文件/图片解析与导出：Playwright（用于 HTML/Mermaid 渲染截图）、Pandoc（用于 docx 导出）
- 存储：  
  - 第一阶段：PostgreSQL（结构化数据）+ 对象存储/本地文件（文档产物、图片、HTML片段、Mermaid 渲染产物）  
  - 内部部署也可先用本地文件 + SQLite，但抄送与检索会很快遇到扩展问题

### 4.2 实体模型（建议）

- `User`：username、password_hash、created_at
- `Document`：doc_id、owner_user_id、title、status、latest_version_id、created_at、updated_at
- `DocumentVersion`：version_id、doc_id、content_md（含 Mermaid/HTML 标记）、doc_variables_json、created_at
- `WorkflowRun`：run_id、doc_id、triggered_by_user_id、status、started_at、ended_at
- `WorkflowNodeRun`：node_run_id、run_id、node_type、input_spec_json、output_json、artifacts_json、status、error
- `DocumentShare`（抄送）：share_id、doc_id、from_user_id、to_user_id、created_at、note（可选）

### 4.3 API（建议）

- Auth  
  - `POST /api/auth/register`  
  - `POST /api/auth/login`（返回 token/cookie）
- Documents  
  - `GET /api/docs/my`（我的）  
  - `GET /api/docs/cc`（抄送给我的）  
  - `POST /api/docs`（创建）  
  - `GET /api/docs/{docId}`（详情：最新版本+变量+分享信息）  
  - `POST /api/docs/{docId}/share`（抄送）
- Workflow  
  - `POST /api/docs/{docId}/workflow/run`（启动一次工作流；可指定从某节点开始）  
  - `GET /api/workflow/runs/{runId}`（run 状态）  
  - `GET /api/workflow/runs/{runId}/stream`（可选：SSE/WS 流式推送节点进度）
- Export  
  - `POST /api/docs/{docId}/export/docx`（生成并返回下载地址/流）

---

## 5. 工作流设计（LangChain）

你定义的节点职责（A~E）建议落地为固定模板（workflow schema），并允许可选分支（D 生图）。

> 更新：实际落地建议使用 **LangGraph** 来表达这套固定模板与失败回流（见第 8.6）。并行不是关键诉求，第一期可按串行执行实现，后续再并行化。

### 5.1 节点定义

#### A：中控对话模型（Controller）
- **职责**  
  - 引导用户把文档需要写的内容说清楚  
  - 记录为 `doc_variables` JSON  
  - 校验完整性（缺什么就追问）
- **输入**  
  - 用户对话历史、当前 doc_variables、引用材料
- **输出**  
  - `doc_variables_patch`：JSON Patch/merge patch  
  - `validation_report`：缺失字段、矛盾点、建议下一问

#### B：文档撰写模型（Writer）
- **职责**  
  - 依据 doc_variables + 材料，撰写/润色文档主体
- **输出**  
  - `draft_md`：Markdown（允许内嵌 Mermaid block 与 HTML block 的占位/引用）

#### C：图文助手（Diagram/HTML Assistant）
- **职责**  
  - 依据需求生成可插入的 Mermaid 图、或 HTML 小页面/组件（如时间线、对比表等）
- **输出**  
  - `mermaid_blocks[]` / `html_blocks[]`（建议带 `id`，便于后续插入与重跑）

#### D：生图助手（Image Assistant，可选）
- **触发条件**  
  - doc_variables 明确标注需要“生成图片辅助”，否则跳过
- **输出**  
  - 图片文件（或对象存储 URL）+ `alt` 文本 + 建议插入位置

#### E：全文助手（Assembler）
- **职责**  
  - 整合 B 的文稿 + C/D 的产物，生成最终版本  
  - 做一致性检查（标题/目录/引用/图表编号/术语）
- **输出**  
  - `final_md`

#### F：VL 解读节点（Vision-Language，可选但推荐第一期就接入）

- **职责**  
  - 对用户在对话区上传的图片/截图/示意图/文件中的图片做解读与要点提取  
  - 输出可写入 `doc_variables` 的结构化信息（术语、结构、流程、界面要点、图中关键标注等）  
- **触发条件**  
  - 用户上传图片，或用户明确要求“基于这张图/这个文件说明概念”  
- **输出**  
  - `vl_summary`：面向写作的要点摘要  
  - `doc_variables_patch`：将可用信息合并进文档变量  
  - `citations`：对应附件/页码/区域（可选）

### 5.2 中间栏“细化提示词（node_prompt_spec）”的建议结构

> 中间栏需要展示“系统给每个节点下发了什么”，因此建议每次节点运行都存 input_spec。

建议字段（示例结构）（中间栏直接展示这些内容即可）：

- `node_type`: "controller" | "writer" | "diagram" | "image" | "assembler"
- `goal`: 本节点目标（中心）
- `constraints`: 注意点/禁忌（口吻、长度、不得编造、引用规则等）
- `materials`: 可参考材料（引用材料索引/摘录）
- `output_format`: 要求输出的结构（JSON schema / Markdown 结构 / Mermaid 类型）
- `variables_snapshot`: 本次运行使用的 doc_variables 快照
- `attachments_snapshot`：本次运行可用的附件清单与引用（图片/文件/解析结果）

---

## 6. 文档存储与呈现（Mermaid 为核心）

### 6.1 内容格式约定

- 文档主内容使用 Markdown。  
- Mermaid 使用 fenced code block：
  - ```mermaid
    graph TD
    A-->B
    ```
- HTML 原型片段（用于表达“原型概念”，不追求美观）使用**受控标记**（便于后端提取并截图导出），推荐最简单的注释包裹形式：
  - `<!--PROTO_HTML:id=xxx-->...<!--/PROTO_HTML-->`
  - `id` 可选；不提供则由后端自动生成并写回 artifacts 映射表

### 6.2 服务端存储

- 原始 `final_md` 必须完整存储（可追溯、可再导出）。  
- Mermaid/HTML 若渲染为图片用于导出，也要存渲染产物（PNG）与版本绑定。

---

## 7. 用户系统与“抄送”功能

### 7.1 登录注册（最简）

- username + password  
- 密码只做基础 hash（如 bcrypt/argon2）；不需要复杂规则，但禁止明文存储  
- 内部使用仍建议：登录限速、防爆破、基本审计日志

### 7.2 “抄送”

- 文档 owner 可抄送给其他用户（按 username 搜索/填写）
- 被抄送者在“抄送”列表可见
- 权限建议（第一期简单）：  
  - 被抄送者：只读（可复制另存为自己的文档）  
  - owner：可撤回抄送（可选）

---

## 8. MD（含 HTML/Mermaid）转 DOCX 下载方案（已定案）

导出目标不是“做得很好看”，而是**“说清楚一件事”**：Word 里能把结构、要点、图示/原型概念讲明白即可。因此导出策略选择最稳、最少坑的路线。

### 8.1 已定案的导出策略

- **输出格式**：仅导出 **`.docx`**  
- **服务端导出**：后端生成文件并提供下载（避免浏览器限制，结果可复现）  
- **统一渲染产物形态**：  
  - Mermaid：渲染为 **PNG** 后再插入 docx  
  - HTML 原型：浏览器渲染后**整块截图为 PNG** 再插入 docx（不追求可编辑还原）

### 8.2 核心链路（实现路径）

1) 读取 `final_md`  
2) 预处理并生成导出用 `export_md`：  
   - 提取 Mermaid blocks → 渲染 PNG → 将原 Mermaid block 替换为 Markdown 图片引用  
   - 提取 `<!--PROTO_HTML-->` blocks → 渲染 PNG → 将原 HTML block 替换为 Markdown 图片引用  
3) 使用 Pandoc：`export_md` → `.docx`（可选：套用统一 docx 模板）

### 8.3 Mermaid/HTML 的服务端渲染实现（建议）

为降低工程复杂度，推荐用 **Playwright（Python）+ Chromium headless** 统一完成两类渲染：

- **Mermaid -> PNG**：在临时 HTML 中加载 Mermaid（本地静态资源/内置脚本均可），把 Mermaid 文本注入并等待渲染完成，对渲染容器截图输出 PNG。  
- **HTML 原型 -> PNG**：把 `<!--PROTO_HTML-->...<!--/PROTO_HTML-->` 内容嵌入“导出模板页”（统一字体/背景/宽度），对容器截图输出 PNG。  

### 8.4 截图宽度/布局标准（对齐 HTML 标准）

- **统一宽度**：截图宽度标准与 HTML 容器宽度标准一致，确保“一张图能表达整个 HTML”。  
- **不追求自适应排版**：以“固定宽度 + 内容自增长高度”为准，减少导出不确定性。  

### 8.5 HTML 原型的约束（只为可控、可截图、可讲清楚）

- **定位**：HTML 仅用于表达“原型概念”，导出时以截图呈现；不承诺复杂 CSS 的精确还原。  
- **建议约束**（内部规则，越简单越稳定）：  
  - 不允许外链 JS/CSS  
  - 不允许网络请求（外链图片需先上传到服务器或转换为可访问的内部路径）  
  - 建议使用基础布局与少量样式（字体/边框/间距/背景色等）

### 8.6 失败处理：不降级，回退给对应操作模型重制（闭环）

导出链路中任意环节失败（Mermaid 渲染失败 / HTML 截图失败 / Pandoc 转换失败）**不做“降级兜底”**，而是进入工作流闭环：把失败原因、失败位置、原始块内容回流给对应的“操作模型”自动重制，直到成功或人工终止。

- **回退原则**：  
  - Mermaid 渲染失败 → 回退给 **C：图文助手**，要求重制 Mermaid（简化语法/避免不兼容特性/拆分子图等）  
  - HTML 截图失败 → 回退给 **C：图文助手**（或图文助手子能力），要求重制为“更可截图、更少依赖”的 HTML 原型块  
  - 全文整合导致块插入异常/引用缺失 → 回退给 **E：全文助手**修正插入位置/引用关系  
  - Pandoc 转换失败（多为 Markdown 结构/资源引用问题）→ 优先回退给 **E：全文助手**修正文稿结构；若定位到某个块导致，则再回退给 C 重制该块

- **错误回流最小输入**（写入中间栏，便于用户看到闭环）：  
  - `error_type`：mermaid_render_failed | html_capture_failed | pandoc_failed | asset_missing  
  - `error_message`：原始错误与简化解释  
  - `block_id` / `block_range`：失败块定位  
  - `block_source`：失败块原始源码（Mermaid 或 HTML）  
  - `retry_guidance`：给对应模型的重制要求（“只求说清楚，不求好看”）

---

## 9. 待你补充的信息（中间栏字段/状态）

中间状态记录的定义已明确：**展示“中控/各操作模型下发的提示词（node_prompt_spec）”与对应节点输出**。第一期实现可以按“时间线卡片”呈现：

- **节点卡片（建议最小字段）**  
  - 节点类型（A/B/C/D/E/F/Export）与状态  
  - 输入：`node_prompt_spec`（goal/constraints/materials/output_format/variables_snapshot/attachments_snapshot）  
  - 输出：Markdown/JSON/图片链接/HTML 原型块源码（可折叠）  
  - 错误：`error_type/error_message`（失败时）  
  - 操作：重跑该节点（第一期足够；是否“从该节点继续”可后续补）

并行关系对第一期不关键：优先保证“可追溯、可重跑、预览渲染正确”。

---

## 10. 模型配置（DashScope 统一调用）

### 10.1 模型服务商与调用方式

- **统一使用阿里云 DashScope** 作为模型推理服务
- 调用方式：通过 `dashscope` Python SDK 或 HTTP API
- 所有模型名与 API Key 通过环境变量配置（见 `env.example`）

### 10.2 节点与模型映射

| 节点 | 职责 | 推荐模型 | 环境变量 |
|------|------|----------|----------|
| A：Controller | 中控对话、澄清需求、变量生成 | `deepseek-r1` | `MODEL_CONTROLLER` |
| B：Writer | 文档撰写、润色 | `deepseek-r1` | `MODEL_WRITER` |
| C：Diagram/HTML | 图文助手（Mermaid/HTML） | `deepseek-r1` | `MODEL_DIAGRAM` |
| D：Image | 生图助手（可选） | 待定（如 wanx） | `MODEL_IMAGE` |
| E：Assembler | 全文整合、一致性检查 | `deepseek-r1` | `MODEL_ASSEMBLER` |
| F：Attachment | 附件分析（文件/图片） | DashScope **LONG**（支持文件直传） | `MODEL_ATTACHMENT_LONG` |

> **F 节点说明**：用户上传文件/图片后，直接调用 DashScope 的 LONG 模型（支持多模态文件直传分析），输出 `attachment_summary` + `doc_variables_patch`，再交给主控模型继续。这样工程上最简便，不需要单独的 VL 流程。

### 10.3 模型调用封装建议

```python
# backend/services/model_client.py
from dashscope import Generation
import os

class DashScopeClient:
    def __init__(self):
        self.api_key = os.getenv("DASHSCOPE_API_KEY")
    
    def call(self, model: str, messages: list, **kwargs) -> dict:
        """统一调用入口，所有节点都通过这个方法调用模型"""
        response = Generation.call(
            model=model,
            messages=messages,
            api_key=self.api_key,
            result_format='message',
            **kwargs
        )
        return response
    
    def call_with_file(self, model: str, messages: list, file_urls: list, **kwargs) -> dict:
        """附件分析专用（LONG 模型支持文件直传）"""
        # LONG 模型的文件传入方式按 DashScope 文档实现
        pass
```

---

## 11. 前端组件结构与样式约定（现代化 UI）

### 11.1 整体布局

```
┌─────────────────────────────────────────────────────────────────┐
│  Header：红点集团内部文档工具  |  用户名  |  我的  |  抄送  |  退出  │
├────────────┬─────────────────────────────┬──────────────────────┤
│            │                             │                      │
│  ChatPanel │       FlowPanel             │    PreviewPanel      │
│  (左侧对话) │    (中间状态记录/节点流)      │   (右侧预览/导出)     │
│            │                             │                      │
│  宽度: 320px│       宽度: flex-1          │     宽度: 480px      │
│  可折叠     │       最小 400px            │     可折叠           │
│            │                             │                      │
└────────────┴─────────────────────────────┴──────────────────────┘
```

### 11.2 组件拆分

```
frontend/src/
├── components/
│   ├── layout/
│   │   ├── Header.tsx          # 顶部导航栏
│   │   ├── ThreeColumnLayout.tsx  # 三栏布局容器
│   │   └── Sidebar.tsx         # 可折叠侧边栏包装
│   ├── chat/
│   │   ├── ChatPanel.tsx       # 左侧对话面板
│   │   ├── MessageList.tsx     # 消息列表（虚拟滚动）
│   │   ├── MessageItem.tsx     # 单条消息
│   │   ├── ChatInput.tsx       # 输入框 + 上传按钮
│   │   └── AttachmentPreview.tsx  # 附件预览卡片
│   ├── flow/
│   │   ├── FlowPanel.tsx       # 中间状态记录面板
│   │   ├── NodeCard.tsx        # 单个节点卡片
│   │   ├── NodePromptSpec.tsx  # 节点下发提示词展示（可折叠）
│   │   ├── NodeOutput.tsx      # 节点输出展示
│   │   └── NodeTimeline.tsx    # 节点时间线/连接线
│   ├── preview/
│   │   ├── PreviewPanel.tsx    # 右侧预览面板
│   │   ├── MarkdownRenderer.tsx   # Markdown 渲染
│   │   ├── MermaidRenderer.tsx    # Mermaid 渲染（带错误定位）
│   │   ├── HtmlSandbox.tsx     # HTML 原型受控容器
│   │   └── ExportButton.tsx    # 导出 DOCX 按钮
│   └── common/
│       ├── Button.tsx
│       ├── Card.tsx
│       ├── Modal.tsx
│       ├── VirtualList.tsx     # 虚拟列表（用于 FlowPanel）
│       └── JsonEditor.tsx      # JSON 编辑器（doc_variables）
├── pages/
│   ├── Login.tsx
│   ├── Register.tsx
│   ├── MyDocs.tsx              # "我的"文档列表
│   ├── SharedDocs.tsx          # "抄送"文档列表
│   └── DocEditor.tsx           # 主编辑页（三栏布局）
├── hooks/
│   ├── useWebSocket.ts         # WebSocket 连接（节点状态推送）
│   ├── useDocVariables.ts      # doc_variables 状态管理
│   └── useFlowRun.ts           # 工作流运行状态
├── services/
│   └── api.ts                  # API 请求封装
└── styles/
    ├── variables.css           # CSS 变量（颜色/间距/字体）
    ├── global.css              # 全局样式
    └── components/             # 组件样式（CSS Modules 或 Tailwind）
```

### 11.3 样式规范（现代化、美观）

#### 设计原则
- **简洁专业**：内部工具，不花哨但要清晰易读
- **信息密度适中**：中间栏节点多时不能显得拥挤
- **状态可视化**：节点状态用颜色+图标明确区分（pending/running/success/fail）

#### 配色建议（深色主题优先，可切换浅色）

```css
:root {
  /* 主色调 - 红点集团品牌色可调整 */
  --color-primary: #E53935;       /* 红点主色 */
  --color-primary-hover: #C62828;
  
  /* 背景层次 */
  --bg-base: #1A1A1A;             /* 最深背景 */
  --bg-surface: #242424;          /* 卡片/面板背景 */
  --bg-elevated: #2E2E2E;         /* 悬浮/弹窗背景 */
  
  /* 文字 */
  --text-primary: #F5F5F5;
  --text-secondary: #A0A0A0;
  --text-muted: #6B6B6B;
  
  /* 状态色 */
  --color-success: #4CAF50;
  --color-warning: #FF9800;
  --color-error: #F44336;
  --color-info: #2196F3;
  --color-pending: #9E9E9E;
  --color-running: #2196F3;
  
  /* 边框与分隔 */
  --border-color: #3A3A3A;
  --border-radius: 8px;
  
  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  
  /* 字体 */
  --font-family: 'Inter', 'PingFang SC', 'Microsoft YaHei', sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
  --font-size-sm: 13px;
  --font-size-base: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 20px;
}
```

#### 节点卡片样式（中间栏核心）

```css
.node-card {
  background: var(--bg-surface);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  transition: border-color 0.2s, box-shadow 0.2s;
}

.node-card--running {
  border-color: var(--color-running);
  box-shadow: 0 0 0 1px var(--color-running);
}

.node-card--success {
  border-left: 3px solid var(--color-success);
}

.node-card--fail {
  border-left: 3px solid var(--color-error);
  background: rgba(244, 67, 54, 0.05);
}

.node-card__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--spacing-sm);
}

.node-card__type {
  font-weight: 600;
  color: var(--text-primary);
}

.node-card__status {
  font-size: var(--font-size-sm);
  padding: 2px 8px;
  border-radius: 4px;
}
```

---

## 12. LangGraph 状态机设计

### 12.1 State Schema

```python
from typing import TypedDict, Literal, Optional, List, Any
from langgraph.graph import StateGraph

class DocVariables(TypedDict, total=False):
    """文档变量（中控澄清产出）"""
    doc_type: str           # 文档类型/主题
    audience: str           # 受众与用途
    outline: List[str]      # 结构/大纲
    key_points: List[str]   # 必须包含的关键点
    materials: List[str]    # 可参考材料来源
    constraints: dict       # 约束（长度、风格、禁忌等）
    # ... 可扩展

class Attachment(TypedDict):
    attachment_id: str
    filename: str
    file_type: str
    url: str
    summary: Optional[str]  # LONG 分析后的摘要

class NodePromptSpec(TypedDict):
    """下发给节点的提示词细化（中间栏展示核心）"""
    node_type: str
    goal: str
    constraints: List[str]
    materials: List[str]
    output_format: str
    variables_snapshot: dict
    attachments_snapshot: List[Attachment]

class NodeResult(TypedDict, total=False):
    """节点输出"""
    draft_md: str
    mermaid_blocks: List[dict]
    html_blocks: List[dict]
    final_md: str
    attachment_summary: str
    doc_variables_patch: dict
    validation_report: dict
    image_urls: List[str]

class ErrorInfo(TypedDict):
    error_type: Literal["mermaid_render_failed", "html_capture_failed", "pandoc_failed", "asset_missing", "model_error", "validation_failed"]
    error_message: str
    block_id: Optional[str]
    block_source: Optional[str]
    retry_guidance: str

class WorkflowState(TypedDict):
    """LangGraph 工作流状态（贯穿整个流程）"""
    doc_id: str
    run_id: str
    user_id: str
    
    # 核心数据
    doc_variables: DocVariables
    attachments: List[Attachment]
    chat_history: List[dict]
    
    # 各节点产物
    draft_md: Optional[str]
    mermaid_blocks: List[dict]
    html_blocks: List[dict]
    image_urls: List[str]
    final_md: Optional[str]
    
    # 当前节点与状态
    current_node: Literal["controller", "writer", "diagram", "image", "assembler", "attachment", "export", "end"]
    node_status: Literal["pending", "running", "success", "fail"]
    
    # 错误与回流
    error: Optional[ErrorInfo]
    retry_count: int
    max_retries: int  # 默认 3
    
    # 节点运行记录（写入中间栏）
    node_runs: List[dict]  # 每个元素包含 node_prompt_spec + node_result + status + error
```

### 12.2 节点定义与 Transitions

```python
from langgraph.graph import StateGraph, END

def build_doc_workflow() -> StateGraph:
    workflow = StateGraph(WorkflowState)
    
    # 添加节点
    workflow.add_node("controller", controller_node)      # A
    workflow.add_node("attachment", attachment_node)      # F
    workflow.add_node("writer", writer_node)              # B
    workflow.add_node("diagram", diagram_node)            # C
    workflow.add_node("image", image_node)                # D
    workflow.add_node("assembler", assembler_node)        # E
    workflow.add_node("export", export_node)              # X
    workflow.add_node("error_router", error_router_node)  # 错误路由
    
    # 入口
    workflow.set_entry_point("controller")
    
    # 正常流程边
    workflow.add_edge("controller", "check_attachments")
    workflow.add_conditional_edges(
        "check_attachments",
        lambda s: "attachment" if s["attachments"] and not all(a.get("summary") for a in s["attachments"]) else "writer",
        {"attachment": "attachment", "writer": "writer"}
    )
    workflow.add_edge("attachment", "controller")  # 附件分析完回到中控确认
    workflow.add_edge("writer", "diagram")
    workflow.add_conditional_edges(
        "diagram",
        lambda s: "image" if s["doc_variables"].get("need_image") else "assembler",
        {"image": "image", "assembler": "assembler"}
    )
    workflow.add_edge("image", "assembler")
    workflow.add_edge("assembler", "export")
    workflow.add_edge("export", END)
    
    # 失败回流边（关键）
    workflow.add_conditional_edges(
        "error_router",
        route_error,
        {
            "controller": "controller",
            "writer": "writer", 
            "diagram": "diagram",
            "assembler": "assembler",
            "export": "export",
            "end": END  # 超过重试次数，终止
        }
    )
    
    return workflow.compile()

def route_error(state: WorkflowState) -> str:
    """根据错误类型决定回流到哪个节点"""
    if state["retry_count"] >= state["max_retries"]:
        return "end"
    
    error = state.get("error")
    if not error:
        return "end"
    
    error_type = error["error_type"]
    
    if error_type in ["mermaid_render_failed", "html_capture_failed"]:
        return "diagram"  # 回流给 C
    elif error_type == "pandoc_failed":
        return "assembler"  # 回流给 E
    elif error_type == "validation_failed":
        return "controller"  # 回流给 A
    elif error_type == "asset_missing":
        return "assembler"  # 回流给 E
    else:
        return "controller"  # 默认回 A
```

### 12.3 节点实现模板

```python
async def controller_node(state: WorkflowState) -> WorkflowState:
    """A：中控对话节点"""
    client = DashScopeClient()
    model = os.getenv("MODEL_CONTROLLER", "deepseek-r1")
    
    # 构造 node_prompt_spec
    prompt_spec: NodePromptSpec = {
        "node_type": "controller",
        "goal": "把用户需求澄清到可执行，形成 doc_variables",
        "constraints": ["不编造", "只求说清楚"],
        "materials": [a["summary"] for a in state["attachments"] if a.get("summary")],
        "output_format": "JSON: doc_variables_patch + validation_report",
        "variables_snapshot": state["doc_variables"],
        "attachments_snapshot": state["attachments"],
    }
    
    # 调用模型
    messages = build_controller_messages(state, prompt_spec)
    response = await client.call(model, messages)
    
    # 解析输出
    result = parse_controller_response(response)
    
    # 记录到 node_runs（写入中间栏）
    node_run = {
        "node_type": "controller",
        "prompt_spec": prompt_spec,
        "result": result,
        "status": "success" if result else "fail",
        "timestamp": datetime.now().isoformat(),
    }
    
    return {
        **state,
        "doc_variables": {**state["doc_variables"], **result.get("doc_variables_patch", {})},
        "node_runs": state["node_runs"] + [node_run],
        "current_node": "controller",
        "node_status": "success",
    }
```

---

## 13. API 接口详细约定

### 13.1 认证

```
POST /api/auth/register
Request:  { "username": string, "password": string }
Response: { "user_id": string, "username": string }

POST /api/auth/login
Request:  { "username": string, "password": string }
Response: { "token": string, "user_id": string, "username": string }
```

### 13.2 文档管理

```
GET /api/docs/my
Response: { "docs": [{ "doc_id", "title", "status", "updated_at" }] }

GET /api/docs/cc
Response: { "docs": [{ "doc_id", "title", "from_user", "shared_at" }] }

POST /api/docs
Request:  { "title"?: string }
Response: { "doc_id": string, "session_id": string }

GET /api/docs/{docId}
Response: {
  "doc_id": string,
  "title": string,
  "owner": { "user_id", "username" },
  "latest_version": { "version_id", "content_md", "doc_variables" },
  "workflow_runs": [{ "run_id", "status", "started_at", "ended_at" }],
  "shares": [{ "to_user", "shared_at" }]
}

POST /api/docs/{docId}/share
Request:  { "to_username": string, "note"?: string }
Response: { "share_id": string }
```

### 13.3 附件上传

```
POST /api/attachments
Content-Type: multipart/form-data
Request:  file + { "doc_id": string }
Response: { 
  "attachment_id": string, 
  "filename": string,
  "url": string,
  "analysis_status": "pending" | "completed",
  "summary"?: string  // LONG 分析完成后有值
}
```

### 13.4 工作流执行

```
POST /api/docs/{docId}/workflow/run
Request: {
  "from_node"?: string,  // 可选，从某节点开始（用于重跑）
  "user_message"?: string,  // 对话消息
  "attachments"?: string[]  // attachment_id 列表
}
Response: { "run_id": string, "status": "started" }

GET /api/workflow/runs/{runId}
Response: {
  "run_id": string,
  "status": "running" | "completed" | "failed",
  "current_node": string,
  "node_runs": [{
    "node_type": string,
    "prompt_spec": NodePromptSpec,
    "result": NodeResult,
    "status": string,
    "error"?: ErrorInfo,
    "timestamp": string
  }],
  "doc_variables": DocVariables,
  "final_md"?: string
}
```

### 13.5 实时状态推送（WebSocket）

```
WS /api/workflow/runs/{runId}/stream

// 服务端推送消息格式
{
  "event": "node_start" | "node_progress" | "node_complete" | "node_error" | "run_complete",
  "data": {
    "node_type": string,
    "prompt_spec"?: NodePromptSpec,
    "result"?: NodeResult,
    "error"?: ErrorInfo,
    "progress"?: number  // 0-100
  }
}
```

### 13.6 导出

```
POST /api/docs/{docId}/export/docx
Request:  { "version_id"?: string, "template"?: string }
Response: { "export_id": string, "status": "processing" }

GET /api/exports/{exportId}
Response: {
  "export_id": string,
  "status": "processing" | "completed" | "failed",
  "download_url"?: string,
  "error"?: ErrorInfo
}
```

---

## 14. 环境变量配置（env.example）

见仓库根目录 `env.example` 文件，包含所有需要配置的环境变量占位。

---

## 15. 下一步（开发顺序建议）

1. **后端骨架**：FastAPI + LangGraph 状态机 + DashScope 调用封装
2. **数据库 + 存储**：PostgreSQL/SQLite + 本地文件存储
3. **核心 API**：认证 → 文档 CRUD → 附件上传 → 工作流执行
4. **前端骨架**：三栏布局 + 样式系统 + 组件占位
5. **对话流程**：ChatPanel + Controller 节点联调
6. **中间栏**：FlowPanel + 节点卡片 + 实时状态推送
7. **预览渲染**：Markdown + Mermaid + HTML Sandbox
8. **导出闭环**：Playwright 渲染 + Pandoc + 失败回流
9. **用户系统**：登录/注册 + 我的/抄送


